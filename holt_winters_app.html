<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prévision dépenses - Holt-Winters</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <style>
    :root { --navy:#0f2744; --light:#f6f8fb; --card:#fff; --muted:#5b6b7b; --accent:#f07a24; --danger:#cc3344; --border:#d8e0ea; }
    body { margin:0; font-family: Inter, Roboto, system-ui, Arial, sans-serif; background:var(--light); color:#102033; }
    .container { max-width:1280px; margin:0 auto; padding:20px; }
    h1,h2,h3 { color:var(--navy); margin:0 0 8px; }
    .grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(330px,1fr)); gap:14px; margin-bottom:14px; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:14px; box-shadow:0 2px 8px rgba(15,39,68,.05); }
    .controls { display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; margin:7px 0; }
    .controls input[type=number], .controls select, .controls input[type=text] { width:95px; padding:6px; border:1px solid var(--border); border-radius:6px; }
    .help { font-size:.82rem; color:var(--muted); margin:2px 0 8px; }
    .dropzone { border:2px dashed #8ea6c1; border-radius:10px; padding:20px; text-align:center; color:var(--muted); background:#fbfcff; }
    .dropzone.drag { border-color:var(--accent); background:#fff5ef; }
    input[type=range] { width:100%; }
    button { background:var(--navy); color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    button.secondary { background:#677a8f; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .muted { color:var(--muted); font-size:.92rem; }
    .table-wrap { overflow:auto; max-height:300px; }
    table { width:100%; border-collapse:collapse; font-size:.9rem; }
    th, td { border-bottom:1px solid var(--border); padding:6px; text-align:right; }
    th:first-child, td:first-child { text-align:left; }
    .err-high { background:#fff0f2; color:var(--danger); font-weight:700; }
    .progress { width:100%; height:14px; border-radius:8px; background:#e8edf3; overflow:hidden; }
    .progress > div { height:100%; width:0%; background:var(--accent); transition:width .15s; }
    #chartBox { background:#fff; border:1px solid var(--border); border-radius:12px; padding:10px; }
    canvas { width:100%; height:430px; }
    .tabs { display:flex; gap:8px; margin:12px 0 8px; }
    .tab-btn { background:#e8edf3; color:#23384f; }
    .tab-btn.active { background:var(--navy); color:#fff; }
    .tab-content { display:none; }
    .tab-content.active { display:block; }
  </style>
</head>
<body>
<div class="container">
  <h1>Démo prévision dépenses - Holt-Winters</h1>

  <div class="grid">
    <div class="card">
      <h2>1) Import CSV</h2>
      <div id="dropzone" class="dropzone">Glissez-déposez un CSV ici ou <input id="fileInput" type="file" accept=".csv" /></div>
      <p id="importInfo" class="muted">Aucune donnée importée.</p>
      <div class="controls"><label>Flux</label><select id="fluxFilter"><option>Dépenses</option><option>Recettes</option></select></div>
      <div class="controls"><label>Titre</label><select id="titreFilter"></select></div>
      <div class="controls"><label>Chapitre</label><select id="chapitreFilter"></select></div>
      <div class="controls"><label>Compte exécution</label><select id="compteFilter"></select></div>
      <div class="controls"><label>Sous compte</label><select id="sousFilter"></select></div>
      <div class="controls"><label>Sous-compte classe 6</label><select id="sous6Filter"></select></div>
      <div class="controls"><label>Libellé du type</label><select id="libelleFilter"></select></div>
      <p id="filterInfo" class="muted">Filtres: tous</p>
      <div class="table-wrap"><table id="previewTable"></table></div>
    </div>

    <div class="card">
      <h2>2) Paramètres Holt-Winters</h2>
      <div class="controls"><label>Mode saisonnier</label><select id="mode"><option value="additive">Additif</option><option value="multiplicative">Multiplicatif</option></select></div>
      <div class="controls"><label>Alpha (α)</label><input id="alpha" type="range" min="0.01" max="1" step="0.01" value="0.2"><input id="alphaNum" type="number" min="0.01" max="1" step="0.01" value="0.2"></div>
      <p class="help">α élevé: suit vite les changements de niveau. α faible: lissage plus stable.</p>
      <div class="controls"><label>Beta (β)</label><input id="beta" type="range" min="0.01" max="1" step="0.01" value="0.1"><input id="betaNum" type="number" min="0.01" max="1" step="0.01" value="0.1"></div>
      <p class="help">β élevé: tendance plus réactive. β faible: tendance plus lissée.</p>
      <div class="controls"><label>Gamma (γ)</label><input id="gamma" type="range" min="0.01" max="1" step="0.01" value="0.3"><input id="gammaNum" type="number" min="0.01" max="1" step="0.01" value="0.3"></div>
      <p class="help">γ élevé: saisonnalité adapte vite les motifs. γ faible: saisonnalité plus stable.</p>
      <div class="controls"><label>Phi (φ)</label><input id="phi" type="range" min="0" max="1" step="0.01" value="0.98"><input id="phiNum" type="number" min="0" max="1" step="0.01" value="0.98"></div>
      <p class="help">φ=1: tendance non amortie. φ&lt;1: tendance qui s'atténue dans le futur.</p>
      <div class="controls"><label>Agrégation</label><select id="aggregation"><option value="1">Mensuel</option><option value="3">Trimestriel</option><option value="4">Quadrimestriel</option><option value="6">Semestriel</option></select></div>
      <div class="controls"><label>Mode cumul</label><select id="cumulMode"><option value="civil">Année civile</option><option value="r12">R12 glissant</option></select></div>
      <p class="muted">Recalcul automatique sur chaque changement.</p>
    </div>

    <div class="card">
      <h2>3) Cutoff & horizon</h2>
      <div class="controls"><label>Cutoff</label><input id="cutoff" type="range" min="24" max="24" step="1" value="24"><input id="cutoffText" type="text" disabled></div>
      <div class="controls"><label>Horizon (mois)</label><input id="horizon" type="range" min="1" max="36" step="1" value="12"><input id="horizonNum" type="number" min="1" max="36" step="1" value="12"></div>
      <p class="muted">IC95% simplifié: ±5% de la prévision (borne basse plafonnée à 0).</p>
      <div class="controls"><label>Focus année</label><select id="yearFocus"><option value="__ALL__">Toutes</option></select></div>
    </div>
  </div>

  <div id="chartBox"><canvas id="chart"></canvas></div>
  <div class="card" style="margin-top:10px;"><h2>Analyse du modèle (niveau / tendance / saisonnalité)</h2><div id="hwInsights" class="muted"></div></div>

  <div class="tabs">
    <button class="tab-btn active" data-tab="tab-performance">Performance annuelle</button>
    <button class="tab-btn" data-tab="tab-projection">Projection fin d'année</button>
  </div>

  <div id="tab-performance" class="tab-content active">
    <div class="grid">
      <div class="card">
        <h2>5) Performance annuelle cumulée</h2>
        <div class="table-wrap"><table id="perfTable"></table></div>
      </div>
      <div class="card">
        <h2>6) Grid Search (α, β, γ)</h2>
        <div class="controls"><label>α min/max/pas</label><span><input id="aMin" type="number" step="0.1" value="0.1"> <input id="aMax" type="number" step="0.1" value="0.8"> <input id="aStep" type="number" step="0.1" value="0.2"></span></div>
        <div class="controls"><label>β min/max/pas</label><span><input id="bMin" type="number" step="0.1" value="0.1"> <input id="bMax" type="number" step="0.1" value="0.8"> <input id="bStep" type="number" step="0.1" value="0.2"></span></div>
        <div class="controls"><label>γ min/max/pas</label><span><input id="gMin" type="number" step="0.1" value="0.1"> <input id="gMax" type="number" step="0.1" value="0.8"> <input id="gStep" type="number" step="0.1" value="0.2"></span></div>
        <div id="yearsChecks" class="muted">Années cibles: importez des données</div><div class="controls"><label>Validation</label><select id="validationMode"><option value="current">Cutoff courant</option><option value="rolling">Rolling origin</option></select></div>
        <div class="controls"><label>Erreur cible (rolling)</label><select id="rollingMetric"><option value="monthly">Erreur mensuelle</option><option value="r12">Erreur R12</option><option value="annual">Erreur Total annuel (YTD + reste)</option></select></div>
        <div class="progress"><div id="progressBar"></div></div>
        <p id="gridResult" class="muted">Aucun calcul.</p>
        <button id="gridBtn" disabled>Lancer le Grid Search</button>
        <button id="applyBest" class="secondary" disabled>Appliquer ces paramètres</button>
        <div class="table-wrap"><table id="top5"></table></div>
      </div>
    </div>
  </div>

  <div id="tab-projection" class="tab-content">
    <div class="card">
      <h2>Projection annuelle (réel + prévision à partir du cutoff)</h2>
      <p class="muted">Pour chaque année, on cumule le réel déjà connu et la prévision HW sur les mois futurs inclus dans l'horizon.</p>
      <div class="table-wrap"><table id="projectionTable"></table></div><h3 style="margin-top:10px;">Comparatif prévision initiale / ajustée / modèle</h3><div class="table-wrap"><table id="budgetCompareTable"></table></div>
    </div>
  </div>
</div>

<script>
const frMonth = new Intl.DateTimeFormat('fr-FR', { month: 'short', year: 'numeric' });
const frMoney = new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
let rawRows = [], filteredRows = [], parsed = [], chart = null, lastBest = null, gridRunning = false;

function fmtMoney(v) { return `${frMoney.format(v || 0)} €`; }
function monthLabel(d) { return frMonth.format(d).replace('.', ''); }
function toMonthStart(d) { return new Date(d.getFullYear(), d.getMonth(), 1); }
function addMonths(d, n) { return new Date(d.getFullYear(), d.getMonth() + n, 1); }
function dampedSum(phi, h){ return Math.abs(phi - 1) < 1e-9 ? h : (phi * (1 - Math.pow(phi, h)) / (1 - phi)); }

function fixMojibake(str){
  return String(str ?? '').replace(/Ã©/g,'é').replace(/Ã¨/g,'è').replace(/Ãª/g,'ê').replace(/Ã /g,'à').replace(/Ã§/g,'ç').replace(/Ã»/g,'û').replace(/Ã´/g,'ô').replace(/Ã‰/g,'É');
}
function normalizeLabel(str){ return fixMojibake(String(str ?? '')).trim(); }
function slug(str){ return normalizeLabel(str).toLowerCase().normalize('NFD').replace(/[̀-ͯ]/g,'').replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,''); }
function monthFromYearMonth(y,m){ const yy=Number(y), mm=Number(m); if(!Number.isFinite(yy)||!Number.isFinite(mm)||mm<1||mm>12) return null; return new Date(yy,mm-1,1); }
function detectColumns(cols){
  const m={};
  cols.forEach(c=>{ const k=slug(c); m[k]=c; });
  return {
    exercice:m.exercice, mois:m.mois, date:m.date,
    titreDep:m.titre_depenses || m.titre_d_penses,
    titreRec:m.titre_recettes,
    chapitre:m.chapitre,
    compte:m.compte_execution || m.compte_ex_cution,
    sous:m.sous_compte,
    sous6:m.sous_compte_classe_6 || m.sous_compte_classe6,
    libelle:m.libelle_du_type || m.libelle_type || m.libell_du_type,
    dep:m.realise_depenses_cumul_realise_date_comptable || m.realis_depenses_cumul_realise_date_comptable,
    rec:m.realise_recettes_cumul_realise_date_comptable || m.realis_recettes_cumul_realise_date_comptable,
    prevDep:m.prevision_depenses_prevision_cumulee || m.prevision_cumulee,
    prevRec:m.prevision_recettes_prevision_cumulee || m.prevision_cumulee,
    bpDep:m.budget_primitif_depense,
    bpRec:m.budget_primitif_recette
  };
}
function splitCSVLine(line, sep){
  const out=[]; let cur='', q=false;
  for(let i=0;i<line.length;i++){
    const ch=line[i];
    if(ch==='"') { q=!q; continue; }
    if(ch===sep && !q){ out.push(cur); cur=''; continue; }
    cur+=ch;
  }
  out.push(cur); return out;
}
function parseCSVRaw(text){
  const lines=text.split(/\r?\n/).map(x=>x.trim()).filter(Boolean); if(!lines.length) return [];
  const sep=(lines[0].split(';').length>=lines[0].split(',').length)?';':',';
  const headers=splitCSVLine(lines[0],sep).map(normalizeLabel);
  const map=detectColumns(headers);
  const rows=[];
  for(let i=1;i<lines.length;i++){
    const vals=splitCSVLine(lines[i],sep); if(vals.length<2) continue;
    const obj={}; headers.forEach((h,idx)=>obj[h]=vals[idx]);
    let date=null;
    if(map.date && obj[map.date]!==undefined) date=parseFrenchDate(obj[map.date]);
    else if(map.exercice && map.mois) date=monthFromYearMonth(obj[map.exercice],obj[map.mois]);
    if(!date) continue;
    const base={date:toMonthStart(date), chapitre:normalizeLabel(obj[map.chapitre]||'(vide)'), compte:normalizeLabel(obj[map.compte]||'(vide)'), sous:normalizeLabel(obj[map.sous]||'(vide)'), sous6:normalizeLabel(obj[map.sous6]||'(vide)'), libelle:normalizeLabel(obj[map.libelle]||'(vide)')};
    const depVal=parseAmount(obj[map.dep]); if(depVal!==null) rows.push({...base, flux:'Dépenses', titre:normalizeLabel(obj[map.titreDep]||'(vide)'), value:depVal, previsionCumulee:parseAmount(obj[map.prevDep]), budgetPrimitif:parseAmount(obj[map.bpDep])});
    const recVal=parseAmount(obj[map.rec]); if(recVal!==null) rows.push({...base, flux:'Recettes', titre:normalizeLabel(obj[map.titreRec]||'(vide)'), value:recVal, previsionCumulee:parseAmount(obj[map.prevRec]), budgetPrimitif:parseAmount(obj[map.bpRec])});
    if(!map.dep && !map.rec && i===1){ const d=parseFrenchDate(vals[0]); const v=parseAmount(vals[1]); if(d&&v!==null) rows.push({date:toMonthStart(d), flux:'Dépenses', titre:'(global)', chapitre:'(global)', compte:'(global)', sous:'(global)', sous6:'(global)', libelle:'(global)', value:v, previsionCumulee:null, budgetPrimitif:null}); }
  }
  return rows;
}
function fillSelect(select, values){
  const opts=['__ALL__', ...values];
  select.innerHTML = opts.map(v=>`<option value="${v}">${v==='__ALL__'?'Tous':v}</option>`).join('');
}
function initFilters(){
  const fluxSel=document.getElementById('fluxFilter');
  const titreSel=document.getElementById('titreFilter'); const chSel=document.getElementById('chapitreFilter');
  const coSel=document.getElementById('compteFilter'); const sSel=document.getElementById('sousFilter'); const s6Sel=document.getElementById('sous6Filter'); const lSel=document.getElementById('libelleFilter');
  const scoped=rawRows.filter(r=>r.flux===fluxSel.value);
  fillSelect(titreSel,[...new Set(scoped.map(r=>r.titre))].sort());
  fillSelect(chSel,[...new Set(scoped.map(r=>r.chapitre))].sort());
  fillSelect(coSel,[...new Set(scoped.map(r=>r.compte))].sort());
  fillSelect(sSel,[...new Set(scoped.map(r=>r.sous))].sort());
  fillSelect(s6Sel,[...new Set(scoped.map(r=>r.sous6))].sort());
  fillSelect(lSel,[...new Set(scoped.map(r=>r.libelle))].sort());
}
function applyFilters(){
  const flux=document.getElementById('fluxFilter').value;
  const titre=document.getElementById('titreFilter').value;
  const chap=document.getElementById('chapitreFilter').value;
  const compte=document.getElementById('compteFilter').value;
  const sous=document.getElementById('sousFilter').value;
  const sous6=document.getElementById('sous6Filter').value;
  const lib=document.getElementById('libelleFilter').value;
  filteredRows=rawRows.filter(r=>
    r.flux===flux &&
    (titre==='__ALL__' || r.titre===titre) &&
    (chap==='__ALL__' || r.chapitre===chap) &&
    (compte==='__ALL__' || r.compte===compte) &&
    (sous==='__ALL__' || r.sous===sous) &&
    (sous6==='__ALL__' || r.sous6===sous6) &&
    (lib==='__ALL__' || r.libelle===lib)
  );
  const dedup = new Map();
  filteredRows.forEach(r=>{ const k=r.date.toISOString().slice(0,7); dedup.set(k,(dedup.get(k)||0)+r.value);});
  parsed=[...dedup.entries()].map(([k,v])=>({date:new Date(k+'-01'), value:v, previsionCumulee:null, budgetPrimitif:null})).sort((a,b)=>a.date-b.date);
  const fi=document.getElementById('filterInfo');
  fi.textContent=`Filtre actif: ${flux} | ${titre==='__ALL__'?'Tous titres':titre} | ${chap==='__ALL__'?'Tous chapitres':chap}`;
}

function parseFrenchDate(raw) {
  const s = String(raw).trim().toLowerCase();
  const months = { janv:1, janvier:1, fev:2, fév:2, fevrier:2, février:2, mars:3, avr:4, avril:4, mai:5, juin:6, juil:7, juillet:7, aout:8, août:8, sept:9, octobre:10, oct:10, nov:11, dec:12, déc:12, décembre:12, decembre:12 };
  let m;
  if ((m = s.match(/^(\d{1,2})\/(\d{4})$/))) return new Date(+m[2], +m[1]-1, 1);
  if ((m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/))) return new Date(+m[3], +m[2]-1, 1);
  if ((m = s.match(/^([a-zéûôîç\.]+)[-\s](\d{4})$/))) { const mm = months[m[1].replace('.', '')]; if (mm) return new Date(+m[2], mm-1, 1); }
  if ((m = s.match(/^(\d{4})[-\/](\d{1,2})$/))) return new Date(+m[1], +m[2]-1, 1);
  const dt = new Date(s); if (!isNaN(dt.getTime())) return new Date(dt.getFullYear(), dt.getMonth(), 1);
  return null;
}

function parseAmount(raw) {
  const s = String(raw).trim().replace(/\s/g, '').replace(/\u00a0/g, '').replace(/\./g, '').replace(',', '.');
  const v = Number(s); return Number.isFinite(v) ? v : null;
}

function buildPreview(){
  const tbl = document.getElementById('previewTable');
  if (!parsed.length){ tbl.innerHTML=''; return; }
  const head = `<tr><th>Date</th><th>Montant</th></tr>`;
  const first = parsed.slice(0,5), last = parsed.slice(-5);
  const rows = [...first, ...(parsed.length>10?[{sep:true}]:[]), ...last].map(r=>r.sep?`<tr><td>...</td><td>...</td></tr>`:`<tr><td>${monthLabel(r.date)}</td><td>${fmtMoney(r.value)}</td></tr>`).join('');
  tbl.innerHTML = head + rows;
  importInfo.textContent = `${parsed.length} mois importés (${monthLabel(parsed[0].date)} → ${monthLabel(parsed[parsed.length-1].date)}).`;
}

function syncPair(range, num, cb){
  range.addEventListener('input', ()=>{ num.value = range.value; cb(); });
  num.addEventListener('input', ()=>{ range.value = num.value; cb(); });
}

function fitHoltWinters(series, alpha, beta, gamma, phi, mode, horizon){
  const m=12; if (series.length < 24) return null;
  const y = series.map(x=>x.value);
  const avg1 = y.slice(0,m).reduce((a,b)=>a+b,0)/m;
  const avg2 = y.slice(m,2*m).reduce((a,b)=>a+b,0)/m;
  let L = avg1, B = (avg2-avg1)/m;
  const S = Array(series.length + horizon + m).fill(mode==='multiplicative'?1:0);
  for (let i=0;i<m;i++) S[i] = mode==='multiplicative' ? (y[i]/avg1 || 1) : (y[i]-avg1);
  const fitted = Array(y.length).fill(null);
  for (let t=m;t<y.length;t++){
    const prev = mode==='multiplicative' ? (L + phi*B) * S[t-m] : (L + phi*B) + S[t-m];
    fitted[t]=prev;
    const prevL=L;
    if (mode==='multiplicative') {
      L = alpha * (y[t] / (S[t-m] || 1)) + (1-alpha) * (L + phi*B);
      B = beta * (L-prevL) + (1-beta) * phi*B;
      S[t] = gamma * (y[t]/(L||1)) + (1-gamma) * S[t-m];
    } else {
      L = alpha * (y[t] - S[t-m]) + (1-alpha) * (L + phi*B);
      B = beta * (L-prevL) + (1-beta) * phi*B;
      S[t] = gamma * (y[t]-L) + (1-gamma) * S[t-m];
    }
  }
  const forecasts=[];
  for (let h=1; h<=horizon; h++){
    const idx = y.length-m+((h-1)%m);
    const trend = dampedSum(phi,h) * B;
    forecasts.push(mode==='multiplicative' ? (L + trend) * S[idx] : (L + trend) + S[idx]);
  }
  return {fitted, forecasts};
}

function aggregateSeries(labels, dates, real, pred, low, high, step){
  if (step===1) return {labels, dates, real, pred, low, high};
  const out = {labels:[], dates:[], real:[], pred:[], low:[], high:[]};
  for(let i=0;i<labels.length;i+=step){
    const chunk = arr => arr.slice(i,i+step).reduce((a,b)=>a+(b??0),0);
    out.labels.push(labels[i]); out.dates.push(dates[i]); out.real.push(chunk(real)); out.pred.push(chunk(pred)); out.low.push(chunk(low)); out.high.push(chunk(high));
  }
  return out;
}

function computeAnnual(realMap, predMap){
  const years = [...new Set(Object.keys(realMap).map(k=>k.slice(0,4)))].sort();
  return years.map(y=>{
    const keys = Object.keys(realMap).filter(k=>k.startsWith(y+'-'));
    const both = keys.filter(k=>predMap[k]!==undefined && predMap[k]!==null && realMap[k]!==null);
    if (both.length!==12) return null;
    const r = both.reduce((a,k)=>a+realMap[k],0), p = both.reduce((a,k)=>a+predMap[k],0), abs = Math.abs(r-p), rel = r===0?0:abs/Math.abs(r)*100;
    return {year:y, label:`${y}`, window:`01/${y} → 12/${y}`, real:r, pred:p, abs, rel};
  }).filter(Boolean);
}

function computeR12(realMap, predMap, cutoffDate){
  const years = [...new Set(Object.keys(realMap).map(k=>+k.slice(0,4)))].sort((a,b)=>a-b);
  const endMonth = cutoffDate.getMonth()+1;
  const rows=[];
  for(const y of years){
    const end = new Date(y, endMonth-1, 1);
    const start = new Date(y, endMonth-1-11, 1);
    let r=0, p=0, covered=0;
    for(let i=0;i<12;i++){
      const d = new Date(start.getFullYear(), start.getMonth()+i, 1);
      const key = d.toISOString().slice(0,7);
      if(realMap[key]!==undefined && predMap[key]!==undefined){
        r += realMap[key]; p += predMap[key]; covered++;
      }
    }
    if(covered===12){
      const abs=Math.abs(r-p), rel=r===0?0:abs/Math.abs(r)*100;
      rows.push({year:y, label:`R12 ${String(y)}`, window:`${monthLabel(start)} → ${monthLabel(end)}`, real:r, pred:p, abs, rel});
    }
  }
  return rows;
}


function mean(arr){ return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : NaN; }
function mae(actual,pred){ if(!actual.length) return NaN; return actual.reduce((s,v,i)=>s+Math.abs(v-pred[i]),0)/actual.length; }
function rmse(actual,pred){ if(!actual.length) return NaN; return Math.sqrt(actual.reduce((s,v,i)=>s+Math.pow(v-pred[i],2),0)/actual.length); }
function mape(actual,pred){
  const vals=[];
  for(let i=0;i<actual.length;i++){
    const den=Math.abs(actual[i]);
    if(den>1e-9) vals.push(Math.abs((actual[i]-pred[i])/den)*100);
  }
  return vals.length?mean(vals):NaN;
}
function smape(actual,pred){
  const vals=[];
  for(let i=0;i<actual.length;i++){
    const den=Math.abs(actual[i])+Math.abs(pred[i]);
    if(den>1e-9) vals.push((2*Math.abs(actual[i]-pred[i])/den)*100);
  }
  return vals.length?mean(vals):NaN;
}

function addMetricBucket(target, actual, pred){
  if(!Number.isFinite(actual) || !Number.isFinite(pred)) return;
  target.actual.push(actual); target.pred.push(pred);
}

function makeMonthKey(d){ return d.toISOString().slice(0,7); }

function rollingOriginBacktestMetrics(series, params, maxOrigins=36){
  const {alpha,beta,gamma,phi,mode}=params;
  const horizon=12;
  const minTrain=24;
  const folds=[];
  const lastOrigin=series.length-2;
  const firstOrigin=minTrain-1;
  if(lastOrigin<firstOrigin) return {folds:[], monthlyByH:new Map(), monthlyAll:{actual:[],pred:[]}, r12All:{actual:[],pred:[]}, annualAll:{actual:[],pred:[]}, annualByMonth:Array.from({length:12},()=>({actual:[],pred:[]}))};
  const candidates=[];
  for(let t=firstOrigin;t<=lastOrigin;t++) candidates.push(t);
  const origins=candidates.slice(Math.max(0,candidates.length-maxOrigins));

  const monthlyByH=new Map(Array.from({length:horizon},(_,i)=>[i+1,{actual:[],pred:[]}]));
  const monthlyAll={actual:[],pred:[]};
  const r12All={actual:[],pred:[]};
  const annualAll={actual:[],pred:[]};
  const annualByMonth=Array.from({length:12},()=>({actual:[],pred:[]}));

  const realMap={};
  series.forEach(r=>{ realMap[makeMonthKey(r.date)] = r.value; });

  for(const originIdx of origins){
    const train=series.slice(0,originIdx+1);
    const fcHorizon=Math.min(horizon, series.length-originIdx-1);
    if(fcHorizon<1) continue;
    const fit=fitHoltWinters(train,alpha,beta,gamma,phi,mode,horizon);
    if(!fit) continue;

    const foldPredMap={};
    for(let h=1; h<=fcHorizon; h++) foldPredMap[makeMonthKey(addMonths(series[originIdx].date,h))]=fit.forecasts[h-1];

    for(let h=1; h<=fcHorizon; h++){
      const dt=addMonths(series[originIdx].date,h);
      const key=makeMonthKey(dt);
      const actual=realMap[key], pred=foldPredMap[key];
      if(Number.isFinite(actual) && Number.isFinite(pred)){
        addMetricBucket(monthlyByH.get(h), actual, pred);
        addMetricBucket(monthlyAll, actual, pred);
      }

      const start=addMonths(dt,-11);
      let r12A=0, r12P=0, ok=true;
      for(let i=0;i<12;i++){
        const mdt=addMonths(start,i);
        const mkey=makeMonthKey(mdt);
        const areal=realMap[mkey];
        if(!Number.isFinite(areal)){ ok=false; break; }
        r12A+=areal;
        let pval;
        if(mdt<=series[originIdx].date){
          pval=areal;
        } else {
          pval=foldPredMap[mkey];
        }
        if(!Number.isFinite(pval)){ ok=false; break; }
        r12P+=pval;
      }
      if(ok) addMetricBucket(r12All,r12A,r12P);
    }

    const originDate=series[originIdx].date;
    const y=originDate.getFullYear();
    let yearReal=0, ytdReal=0, remPred=0, hasYear=true, hasPred=true;
    for(let m=0;m<12;m++){
      const dt=new Date(y,m,1);
      const key=makeMonthKey(dt);
      const rv=realMap[key];
      if(!Number.isFinite(rv)){ hasYear=false; break; }
      yearReal+=rv;
      if(m<=originDate.getMonth()) ytdReal+=rv;
      else {
        const pv=foldPredMap[key];
        if(!Number.isFinite(pv)){ hasPred=false; break; }
        remPred+=pv;
      }
    }
    if(hasYear && hasPred){
      const annualPred=ytdReal+remPred;
      addMetricBucket(annualAll, yearReal, annualPred);
      addMetricBucket(annualByMonth[originDate.getMonth()], yearReal, annualPred);
      folds.push({originDate, year, annualReal:yearReal, annualPred});
    }
  }

  return {folds, monthlyByH, monthlyAll, r12All, annualAll, annualByMonth};
}

function summarizeMetricBucket(bucket){
  const actual=bucket.actual, pred=bucket.pred;
  if(!actual.length) return {count:0, mae:NaN, rmse:NaN, mape:NaN, smape:NaN};
  return {count:actual.length, mae:mae(actual,pred), rmse:rmse(actual,pred), mape:mape(actual,pred), smape:smape(actual,pred)};
}

function buildProjectionTable(cutoffIdx, forecasts){
  const horizon = forecasts.length;
  const end = addMonths(parsed[cutoffIdx].date, horizon);
  const years = [];
  for (let y=parsed[0].date.getFullYear(); y<=end.getFullYear(); y++) years.push(y);

  const realMap = {}; parsed.forEach(r=>realMap[r.date.toISOString().slice(0,7)] = r.value);
  const rows = years.map(year=>{
    let realCum=0, projCum=0, months=0;
    for(let m=0;m<12;m++){
      const dt = new Date(year,m,1);
      const key = dt.toISOString().slice(0,7);
      const idx = (year - parsed[cutoffIdx].date.getFullYear())*12 + (m - parsed[cutoffIdx].date.getMonth()) - 1;
      const real = realMap[key];
      if (real!==undefined) realCum += real;
      let proj = null;
      if (dt <= parsed[cutoffIdx].date && real!==undefined) proj = real;
      if (idx>=0 && idx<forecasts.length) proj = forecasts[idx];
      if (proj!==null) { projCum += proj; months++; }
    }
    if (months===0) return null;
    const abs = Math.abs(realCum-projCum), rel = realCum===0?0:abs/Math.abs(realCum)*100;
    return {year, realCum, projCum, abs, rel, months};
  }).filter(Boolean);

  projectionTable.innerHTML = '<tr><th>Année</th><th>Réel cumulé</th><th>Prévision cumulée</th><th>Écart abs.</th><th>Écart rel.</th><th>Mois couverts</th></tr>' +
    rows.map(r=>`<tr class="${r.rel>5?'err-high':''}"><td>${r.year}</td><td>${fmtMoney(r.realCum)}</td><td>${fmtMoney(r.projCum)}</td><td>${fmtMoney(r.abs)}</td><td>${r.rel.toFixed(2)}%</td><td>${r.months}</td></tr>`).join('');
}


function shiftRightOneMonth(weights){
  return weights.map((_,m)=>weights[(m+11)%12]);
}

function getYearFocusBounds(dates, yearValue){
  if(yearValue==='__ALL__') return null;
  const y=+yearValue;
  if(!Number.isFinite(y)) return null;
  const idx=dates.map((d,i)=>d.getFullYear()===y?i:-1).filter(i=>i>=0);
  if(!idx.length) return null;
  return {min:Math.max(0,idx[0]-1), max:Math.min(dates.length-1, idx[idx.length-1]+1)};
}

const yearBandsPlugin = {
  id:'yearBandsPlugin',
  beforeDraw(chart, _args, opts){
    const x=chart.scales.x, area=chart.chartArea;
    if(!x||!area||!opts||!opts.dates||!opts.dates.length) return;
    const dates=opts.dates;
    const ctx=chart.ctx;
    const years=[...new Set(dates.map(d=>d.getFullYear()))].sort((a,b)=>a-b);
    years.forEach((year, yi)=>{
      const id=dates.map((d,i)=>d.getFullYear()===year?i:-1).filter(i=>i>=0);
      if(!id.length) return;
      const left=x.getPixelForValue(id[0])-6;
      const right=x.getPixelForValue(id[id.length-1])+6;
      ctx.save();
      ctx.fillStyle = yi%2===0 ? 'rgba(15,39,68,0.035)' : 'rgba(240,122,36,0.03)';
      ctx.fillRect(left, area.top, right-left, area.bottom-area.top);
      ctx.restore();
    });
    dates.forEach((d,i)=>{
      if(d.getMonth()!==11) return;
      const xp=x.getPixelForValue(i);
      ctx.save();
      ctx.strokeStyle='rgba(15,39,68,0.20)';
      ctx.setLineDash([3,4]);
      ctx.beginPath();
      ctx.moveTo(xp, area.top);
      ctx.lineTo(xp, area.bottom);
      ctx.stroke();
      ctx.restore();
    });
  }
};

function seasonalityWeightsFromParsed(){
  const byMonth=Array(12).fill(0), cnt=Array(12).fill(0);
  const base = parsed.some(r=>r.date.getFullYear()<2025) ? parsed.filter(r=>r.date.getFullYear()<2025) : parsed;
  base.forEach(r=>{ const m=r.date.getMonth(); byMonth[m]+=Math.max(0,r.value); cnt[m]++; });
  const raw=byMonth.map((v,i)=>cnt[i]?v/cnt[i]:0);
  const sum=raw.reduce((a,b)=>a+b,0);
  return sum>0?raw.map(v=>v/sum):Array(12).fill(1/12);
}
function seasonalizedBudgetSeries(weightInitial=0.7){
  if(!filteredRows.length) return {initialMap:{}};
  const weights=shiftRightOneMonth(seasonalityWeightsFromParsed());

  // Agrégation correcte: somme des maxima par sous-compte (évite de compter 12 fois le même budget annuel)
  const byYearKey={};
  filteredRows.forEach(r=>{
    const y=r.date.getFullYear();
    const key = (r.sous && r.sous !== '(vide)') ? r.sous : ((r.compte && r.compte !== '(vide)') ? r.compte : r.titre);
    const k=`${y}__${key}`;
    if(!byYearKey[k]) byYearKey[k]={year:y, bp:0, adj:0};
    // Budget primitif souvent stocké au mois (annuel/12) -> reconstruction annuelle.
    byYearKey[k].bp = Math.max(byYearKey[k].bp, Number(r.budgetPrimitif||0) * 12);
    byYearKey[k].adj = Math.max(byYearKey[k].adj, Number(r.previsionCumulee||0));
  });

  const yearVals={};
  Object.values(byYearKey).forEach(v=>{
    const y=v.year;
    yearVals[y]=yearVals[y]||{bp:0,adj:0};
    yearVals[y].bp += v.bp;
    yearVals[y].adj += v.adj;
  });

  const initialMap={};
  Object.entries(yearVals).forEach(([ys,v])=>{
    const y=+ys;
    for(let m=0;m<12;m++){
      const key=new Date(y,m,1).toISOString().slice(0,7);
      initialMap[key]=v.bp*weights[m];
      
    }
  });
  return {initialMap};
}
function buildBudgetCompareTable(predMap, cutoffDate){
  const {initialMap}=seasonalizedBudgetSeries(0.7);
  const years=[...new Set(parsed.map(r=>r.date.getFullYear()))].sort((a,b)=>a-b);
  const realMap={}; parsed.forEach(r=>realMap[r.date.toISOString().slice(0,7)] = r.value);
  const rows=years.map(y=>{
    let real=0, ini=0, model=0, covered=0;
    for(let m=0;m<12;m++){
      const key=new Date(y,m,1).toISOString().slice(0,7);
      if(realMap[key]!==undefined) real+=realMap[key];
      if(initialMap[key]!==undefined) ini+=initialMap[key];
      
      if(predMap[key]!==undefined){ model+=predMap[key]; covered++; }
    }
    if(covered===0) return null;
    return {y, real, ini, model};
  }).filter(Boolean);
  budgetCompareTable.innerHTML='<tr><th>Année</th><th>Σ Réel</th><th>Σ Budget primitif saisonnalisé</th><th>Σ Prévision modèle</th></tr>' + rows.map(r=>`<tr><td>${r.y}</td><td>${fmtMoney(r.real)}</td><td>${fmtMoney(r.ini)}</td><td>${fmtMoney(r.model)}</td></tr>`).join('');
}


function buildHwInsights(){
  if(parsed.length<24){ hwInsights.textContent='Pas assez de données pour analyser le niveau/tendance/saisonnalité.'; return; }
  const vals=parsed.map(r=>r.value);
  const mean=vals.reduce((a,b)=>a+b,0)/vals.length;
  const std=Math.sqrt(vals.reduce((a,b)=>a+Math.pow(b-mean,2),0)/Math.max(1,vals.length));
  const byMonth=Array.from({length:12},()=>[]);
  parsed.forEach(r=>byMonth[r.date.getMonth()].push(r.value));
  const mMeans=byMonth.map(a=>a.length?a.reduce((x,y)=>x+y,0)/a.length:mean);
  const seasStd=Math.sqrt(mMeans.reduce((a,b)=>a+Math.pow(b-(mMeans.reduce((x,y)=>x+y,0)/12),2),0)/12);
  const seasonalityRatio=seasStd/Math.max(std,1e-9);
  const n=parsed.length;
  const old=parsed.slice(Math.max(0,n-24), Math.max(0,n-12));
  const cur=parsed.slice(Math.max(0,n-12));
  const avg=a=>a.reduce((x,y)=>x+y.value,0)/Math.max(1,a.length);
  const oldMean=avg(old), curMean=avg(cur);
  const levelShift=((curMean-oldMean)/Math.max(Math.abs(oldMean),1))*100;
  const oldTrend=old.length?old[old.length-1].value-old[0].value:0;
  const curTrend=cur.length?cur[cur.length-1].value-cur[0].value:0;
  const trendShift=((curTrend-oldTrend)/Math.max(Math.abs(oldTrend),1))*100;
  hwInsights.innerHTML=`
  - Niveau moyen ancien (${old.length?monthLabel(old[0].date):'n/a'} → ${old.length?monthLabel(old[old.length-1].date):'n/a'}) vs récent (${monthLabel(cur[0].date)} → ${monthLabel(cur[cur.length-1].date)}): <b>${levelShift>=0?'+':''}${levelShift.toFixed(1)}%</b><br>
  - Tendance (pente 12 mois) : <b>${trendShift>=0?'+':''}${trendShift.toFixed(1)}%</b> (ancien→récent)<br>
  - Saisonnalité estimée : <b>${seasonalityRatio>0.35?'forte':seasonalityRatio>0.15?'modérée':'faible'}</b> (ratio=${seasonalityRatio.toFixed(2)})<br>
  - Interprétation: si niveau et tendance montent fortement, la prévision initiale doit être revue tôt dans l'année.
  `;
}

function recompute(){
  if (parsed.length < 24){
    if(parsed.length>0) importInfo.textContent += " | Série filtrée insuffisante (<24 mois).";
    return;
  }
  const alpha=+alphaEl.value, beta=+betaEl.value, gamma=+gammaEl.value, phi=+phiEl.value;
  const mode=modeEl.value, cutoffIdx=+cutoffEl.value, horizon=+horizonEl.value, agg=+aggregationEl.value, cumulMode=cumulModeEl.value;
  const hw = fitHoltWinters(parsed.slice(0, cutoffIdx+1), alpha,beta,gamma,phi,mode,horizon);
  if (!hw) return;
  cutoffText.value = monthLabel(parsed[cutoffIdx].date);

  const labels = parsed.map(r=>monthLabel(r.date));
  const preReal = parsed.map((r,i)=> i<=cutoffIdx ? r.value : null);
  const postReal = parsed.map((r,i)=> i>cutoffIdx ? r.value : null);
  const pred = Array(parsed.length + horizon).fill(null), low = Array(parsed.length + horizon).fill(null), high = Array(parsed.length + horizon).fill(null), budgetInit=Array(parsed.length + horizon).fill(null);

  for(let i=0;i<hw.fitted.length;i++) if(hw.fitted[i]!=null){ pred[i]=hw.fitted[i]; low[i]=Math.max(0, pred[i]*0.95); high[i]=pred[i]*1.05; }
  const extLabels=[...labels];
  const extDates=[];
  for(let i=0;i<parsed.length+horizon;i++) extDates.push(i<parsed.length?parsed[i].date:addMonths(parsed[parsed.length-1].date,i-parsed.length+1));
  for(let h=1; h<=horizon; h++){
    const idx=cutoffIdx+h, d=addMonths(parsed[cutoffIdx].date,h), v=hw.forecasts[h-1];
    if(!extLabels[idx]) extLabels[idx]=monthLabel(d);
    pred[idx]=v; low[idx]=Math.max(0, v*0.95); high[idx]=v*1.05;
  }

  const budgetMaps = seasonalizedBudgetSeries(0.7);
  extLabels.forEach((_,i)=>{ const dt=extDates[i]; const key=dt.toISOString().slice(0,7); budgetInit[i]=budgetMaps.initialMap[key]??null; });
  const ag = aggregateSeries(extLabels, extDates, [...preReal,...Array(horizon).fill(null)], [...pred], [...low], [...high], agg);
  const budgetInitAg=aggregateSeries(extLabels, extDates, Array(extLabels.length).fill(null), [...budgetInit], [...low], [...high], agg);
  const postAg = aggregateSeries(extLabels, extDates, [...postReal,...Array(horizon).fill(null)], [...pred], [...low], [...high], agg);
  if (chart) chart.destroy();
  chart = new Chart(document.getElementById('chart'), {
    type:'line', data:{ labels:ag.labels, datasets:[
      {label:'Réel (pré-cutoff)', data:ag.real, borderColor:'#2f6db3', borderWidth:3, pointRadius:0, tension:0.35, cubicInterpolationMode:'monotone'},
      {label:'Réel (post-cutoff)', data:postAg.real, borderColor:'#8eb6dd', borderDash:[6,4], borderWidth:3, pointRadius:0, tension:0.35, cubicInterpolationMode:'monotone'},
      {label:'IC95% bas', data:ag.low, borderColor:'rgba(0,0,0,0)', pointRadius:0, fill:false},
      {label:'IC95%', data:ag.high, borderColor:'rgba(0,0,0,0)', backgroundColor:'rgba(120,120,120,.2)', pointRadius:0, fill:'-1'},
      {label:'Budget primitif saisonnalisé', data:budgetInitAg.pred, borderColor:'#5b4bc4', borderDash:[2,4], borderWidth:3, pointRadius:0, tension:0.35, cubicInterpolationMode:'monotone'},
            {label:'Prévision HW', data:ag.pred, borderColor:'#f07a24', borderWidth:3, pointRadius:0, tension:0.35, cubicInterpolationMode:'monotone'}
    ]},
    options:{ responsive:true, interaction:{mode:'index', intersect:false}, scales:{ y:{ ticks:{ callback:v=>frMoney.format(v) } } },
      plugins:{ legend:{position:'top'}, tooltip:{callbacks:{label:(ctx)=>`${ctx.dataset.label}: ${fmtMoney(ctx.raw)}`}},
        zoom:{ pan:{enabled:true, mode:'x', modifierKey:null}, zoom:{wheel:{enabled:true}, pinch:{enabled:true}, drag:{enabled:false}, mode:'x'} },
        yearBandsPlugin:{ dates: ag.dates } } },
    plugins:[yearBandsPlugin]
  });
  const bounds = getYearFocusBounds(ag.dates, yearFocusEl.value);
  if(bounds){
    chart.options.scales = chart.options.scales || {};
    chart.options.scales.x = chart.options.scales.x || {};
    chart.options.scales.x.min = bounds.min;
    chart.options.scales.x.max = bounds.max;
    chart.update('none');
  }

  const realMap = {}; parsed.forEach(r=>realMap[r.date.toISOString().slice(0,7)] = r.value);
  const predMap = {}; pred.forEach((v,i)=>{ if(v==null) return; const dt=i<parsed.length?parsed[i].date:addMonths(parsed[parsed.length-1].date,i-parsed.length+1); predMap[dt.toISOString().slice(0,7)] = v;});
  const rows = cumulMode==='r12' ? computeR12(realMap,predMap,parsed[cutoffIdx].date) : computeAnnual(realMap,predMap);
  const headLabel = cumulMode==='r12' ? "Fenêtre" : "Année";
  if(cumulMode==='civil'){
    const budgetMap=budgetMaps.initialMap;
    perfTable.innerHTML = `<tr><th>${headLabel}</th><th>Σ Réel</th><th>Σ Prévision modèle</th><th>Σ Budget primitif</th><th>Écart modèle vs réel</th><th>Écart modèle %</th><th>Écart budget vs réel</th><th>Écart budget %</th></tr>` + rows.map(r=>{
      const y=+r.year; let budget=0;
      for(let m=0;m<12;m++){ const key=new Date(y,m,1).toISOString().slice(0,7); budget += Number(budgetMap[key]||0); }
      const bAbs=Math.abs(r.real-budget), bRel=r.real===0?0:bAbs/Math.abs(r.real)*100;
      return `<tr class="${Math.min(r.rel,bRel)>5?'err-high':''}"><td>${r.label}</td><td>${fmtMoney(r.real)}</td><td>${fmtMoney(r.pred)}</td><td>${fmtMoney(budget)}</td><td>${fmtMoney(r.abs)}</td><td>${r.rel.toFixed(2)}%</td><td>${fmtMoney(bAbs)}</td><td>${bRel.toFixed(2)}%</td></tr>`;
    }).join('');
  } else {
    perfTable.innerHTML = `<tr><th>${headLabel}</th><th>Σ Réel</th><th>Σ Prévision modèle</th><th>Écart modèle vs réel</th><th>Écart modèle vs réel %</th></tr>` + rows.map(r=>`<tr class="${r.rel>5?'err-high':''}"><td>${cumulMode==='r12'?r.window:r.label}</td><td>${fmtMoney(r.real)}</td><td>${fmtMoney(r.pred)}</td><td>${fmtMoney(r.abs)}</td><td>${r.rel.toFixed(2)}%</td></tr>`).join('');
  }
  buildProjectionTable(cutoffIdx, hw.forecasts);
  buildBudgetCompareTable(predMap, parsed[cutoffIdx].date);
  buildHwInsights();
}

async function runGrid(){
  if (gridRunning) return;
  const checks = [...document.querySelectorAll('#yearsChecks input[type=checkbox]:checked')].map(c=>String(c.value));
  if (!checks.length) { alert('Sélectionnez au moins une année cible.'); return; }
  const range = (min,max,step)=>{ if(step<=0||max<min) return []; const out=[]; for(let x=min; x<=max+1e-9; x+=step) out.push(+x.toFixed(4)); return out; };
  const as=range(+aMin.value,+aMax.value,+aStep.value), bs=range(+bMin.value,+bMax.value,+bStep.value), gs=range(+gMin.value,+gMax.value,+gStep.value);
  const total = as.length*bs.length*gs.length; if(!total){ gridResult.textContent='Paramètres de grille invalides.'; return; }

  const cutoffIdx=+cutoffEl.value, mode=modeEl.value, phi=+phiEl.value, fitSeries=parsed.slice(0,cutoffIdx+1), monthsAfterCutoff=Math.max(1, parsed.length-cutoffIdx-1), validationMode=validationModeEl.value;
  const rollingMetric=rollingMetricEl.value;
  const realMap={}; parsed.forEach(r=>realMap[r.date.toISOString().slice(0,7)] = r.value);
  gridRunning=true; gridBtn.disabled=true; progressBar.style.width='0%'; top5.innerHTML=''; gridResult.textContent=`Calcul en cours (${total} combinaisons)...`;

  const top=[]; let done=0;
  for(const a of as){ for(const b of bs){ for(const g of gs){
    const hw=fitHoltWinters(fitSeries,a,b,g,phi,mode,monthsAfterCutoff);
    if(hw){
      let score=Infinity, scoreCount=0, diagnostic='';
      let annualByMonthTable='';
      if(validationMode==='rolling'){
        const bt=rollingOriginBacktestMetrics(parsed,{alpha:a,beta:b,gamma:g,phi,mode},24);
        const monthlySummary=summarizeMetricBucket(bt.monthlyAll);
        const r12Summary=summarizeMetricBucket(bt.r12All);
        const annualSummary=summarizeMetricBucket(bt.annualAll);
        scoreCount = rollingMetric==='monthly' ? monthlySummary.count : (rollingMetric==='r12' ? r12Summary.count : annualSummary.count);
        score = rollingMetric==='monthly' ? monthlySummary.rmse : (rollingMetric==='r12' ? r12Summary.rmse : annualSummary.rmse);

        const monthRows = bt.annualByMonth.map((bkt,idx)=>{
          const s=summarizeMetricBucket(bkt);
          if(!s.count) return '';
          const rel = Number.isFinite(s.mape) ? `${s.mape.toFixed(2)}%` : `${s.smape.toFixed(2)}% (sMAPE)`;
          return `<tr><td>${idx+1}</td><td>${s.count}</td><td>${fmtMoney(s.mae)}</td><td>${rel}</td></tr>`;
        }).filter(Boolean).join('');
        annualByMonthTable = monthRows ? `<br><span class="muted">Erreur total annuel par mois d'origine (best):</span><table><tr><th>Mois origine</th><th>n</th><th>MAE total annuel</th><th>Erreur relative</th></tr>${monthRows}</table>` : '';
        diagnostic = `rolling ${rollingMetric} | folds=${bt.folds.length}`;
      } else {
        const scoreYears=[];
        const predMap={}; hw.fitted.forEach((v,i)=>{ if(v!=null) predMap[parsed[i].date.toISOString().slice(0,7)] = v; });
        for(let h=1; h<=monthsAfterCutoff; h++) predMap[addMonths(parsed[cutoffIdx].date,h).toISOString().slice(0,7)] = hw.forecasts[h-1];
        scoreYears.push(...(cumulModeEl.value==='r12' ? computeR12(realMap,predMap,parsed[cutoffIdx].date) : computeAnnual(realMap,predMap)).filter(r=>checks.includes(String(r.year))));
        score=scoreYears.length ? scoreYears.reduce((x,r)=>x+r.rel,0) : Infinity;
        scoreCount=scoreYears.length;
        diagnostic = `cutoff courant | années=${scoreYears.length}`;
      }

      const trainVals = fitSeries.map(x=>x.value);
      const trainMean = trainVals.reduce((x,y)=>x+y,0)/Math.max(1,trainVals.length);
      const maxForecast = Math.max(...hw.forecasts);
      const minForecast = Math.min(...hw.forecasts);
      const absurdScale = maxForecast > trainMean * 8 || minForecast < -Math.abs(trainMean) * 2;
      if (Number.isFinite(score) && scoreCount>0 && !absurdScale) {
        top.push({a,b,g,score,diagnostic,annualByMonthTable});
        top.sort((x,y)=>x.score-y.score);
        if(top.length>5) top.pop();
      }
    }
    done++; progressBar.style.width=`${(100*done/total).toFixed(1)}%`;
  }} await new Promise(r=>setTimeout(r,0)); }

  if (!top.length){ gridResult.textContent='Aucune combinaison valide pour le mode/métrique sélectionné(e).'; applyBest.disabled=true; }
  else {
    lastBest=top[0];
    const scoreLabel = validationMode==='rolling' ? `score RMSE (${rollingMetric})` : 'score cumulé';
    gridResult.innerHTML=`Meilleur: α=${lastBest.a}, β=${lastBest.b}, γ=${lastBest.g} | ${scoreLabel}=${lastBest.score.toFixed(3)}<br><span class="muted">${lastBest.diagnostic}</span>${lastBest.annualByMonthTable}`;
    applyBest.disabled=false;
    top5.innerHTML='<tr><th>Rang</th><th>α</th><th>β</th><th>γ</th><th>Score</th><th>Contexte</th></tr>'+top.map((r,i)=>`<tr><td>${i+1}</td><td>${r.a}</td><td>${r.b}</td><td>${r.g}</td><td>${r.score.toFixed(3)}</td><td>${r.diagnostic}</td></tr>`).join('');
  }
  gridRunning=false; gridBtn.disabled=parsed.length<24;
}

const fileInput=document.getElementById('fileInput'), dropzone=document.getElementById('dropzone');
const alphaEl=document.getElementById('alpha'), alphaNum=document.getElementById('alphaNum');
const betaEl=document.getElementById('beta'), betaNum=document.getElementById('betaNum');
const gammaEl=document.getElementById('gamma'), gammaNum=document.getElementById('gammaNum');
const phiEl=document.getElementById('phi'), phiNum=document.getElementById('phiNum');
const horizonEl=document.getElementById('horizon'), horizonNum=document.getElementById('horizonNum');
const cutoffEl=document.getElementById('cutoff'), cutoffText=document.getElementById('cutoffText');
const modeEl=document.getElementById('mode'), aggregationEl=document.getElementById('aggregation'), cumulModeEl=document.getElementById('cumulMode'), validationModeEl=document.getElementById('validationMode'), rollingMetricEl=document.getElementById('rollingMetric');
const gridBtn=document.getElementById('gridBtn'), applyBest=document.getElementById('applyBest');
const perfTable=document.getElementById('perfTable'), projectionTable=document.getElementById('projectionTable'), budgetCompareTable=document.getElementById('budgetCompareTable'), hwInsights=document.getElementById('hwInsights');
const yearFocusEl=document.getElementById('yearFocus');

function updateYearFocus(){
  if(!parsed.length){ yearFocusEl.innerHTML='<option value="__ALL__">Toutes</option>'; return; }
  const years=[...new Set(parsed.map(r=>r.date.getFullYear()))].sort((a,b)=>a-b);
  yearFocusEl.innerHTML=['<option value="__ALL__">Toutes</option>',...years.map(y=>`<option value="${y}">${y}</option>`)].join('');
}

function updateYearsForGrid(){
  if(!parsed.length){ yearsChecks.textContent='Années cibles: importez des données'; return; }
  const years=[...new Set(parsed.map(r=>r.date.getFullYear()))].filter(y=>y>=2020);
  yearsChecks.innerHTML='Années cibles: '+years.map(y=>`<label style="margin-right:8px;"><input type="checkbox" value="${y}" checked> ${y}</label>`).join('');
}

function loadFile(file){
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    rawRows = parseCSVRaw(reader.result);
    initFilters();
    applyFilters();
    buildPreview(); updateYearsForGrid(); updateYearFocus();
    cutoffEl.min=24; cutoffEl.max=Math.max(24, parsed.length-1); cutoffEl.value=Math.max(24, parsed.length-1);
    gridBtn.disabled = parsed.length < 24;
    recompute();
  };
  reader.readAsText(file, 'utf-8');
}

fileInput.onchange = (e)=>loadFile(e.target.files[0]);
['dragenter','dragover'].forEach(evt=>dropzone.addEventListener(evt,(e)=>{e.preventDefault(); dropzone.classList.add('drag');}));
['dragleave','drop'].forEach(evt=>dropzone.addEventListener(evt,(e)=>{e.preventDefault(); dropzone.classList.remove('drag');}));
dropzone.addEventListener('drop', (e)=>loadFile(e.dataTransfer.files[0]));

["fluxFilter","titreFilter","chapitreFilter","compteFilter","sousFilter","sous6Filter","libelleFilter"].forEach(id=>document.getElementById(id).addEventListener("change",()=>{ if(id==="fluxFilter") initFilters(); applyFilters(); buildPreview(); updateYearsForGrid(); updateYearFocus(); cutoffEl.max=Math.max(24, parsed.length-1); cutoffEl.value=Math.min(+cutoffEl.value, +cutoffEl.max); gridBtn.disabled = parsed.length < 24; recompute(); }));

syncPair(alphaEl, alphaNum, recompute); syncPair(betaEl, betaNum, recompute); syncPair(gammaEl, gammaNum, recompute); syncPair(phiEl, phiNum, recompute); syncPair(horizonEl, horizonNum, recompute);
cutoffEl.addEventListener('input', recompute); modeEl.addEventListener('change', recompute); aggregationEl.addEventListener('change', recompute); cumulModeEl.addEventListener('change', recompute); validationModeEl.addEventListener('change', recompute); rollingMetricEl.addEventListener('change', recompute); yearFocusEl.addEventListener('change', recompute);
gridBtn.addEventListener('click', runGrid);
applyBest.addEventListener('click', ()=>{ if(!lastBest) return; alphaEl.value=alphaNum.value=lastBest.a; betaEl.value=betaNum.value=lastBest.b; gammaEl.value=gammaNum.value=lastBest.g; recompute(); });

[...document.querySelectorAll('.tab-btn')].forEach(btn=>btn.addEventListener('click', ()=>{
  document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
  btn.classList.add('active'); document.getElementById(btn.dataset.tab).classList.add('active');
}));
</script>
</body>
</html>
